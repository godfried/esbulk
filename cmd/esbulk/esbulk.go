package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"runtime"
	"runtime/pprof"
	"strings"
	"sync"
	"time"

	"github.com/miku/esbulk"
)

// Version of application.
const Version = "0.6.2-eval"

var (
	version    = flag.Bool("v", false, "prints current program version")
	cpuprofile = flag.String("cpuprofile", "", "write cpu profile to file")
	memprofile = flag.String("memprofile", "", "write heap profile to file")
	indexName  = flag.String("index", "", "index name")
	docType    = flag.String("type", "default", "elasticsearch doc type")
	batchSize  = flag.Int("size", 1000, "bulk batch size")
	numWorkers = flag.Int("w", runtime.NumCPU(), "number of workers to use")
	maxProcs   = flag.Int("maxprocs", runtime.NumCPU(), "number of processors to use")
	verbose    = flag.Bool("verbose", false, "output basic progress")
	mapping    = flag.String("mapping", "", "mapping string or filename to apply before indexing")
	purge      = flag.Bool("purge", false, "purge any existing index before indexing")
	idfield    = flag.String("id", "", "name of field to use as id field, by default ids are autogenerated")
	user       = flag.String("u", "", "http basic auth username:password, like curl -u")
)

func main() {
	var serverFlags esbulk.ArrayFlags
	flag.Var(&serverFlags, "server", "elasticsearch server, this works with https as well")

	flag.Parse()

	if *cpuprofile != "" {
		f, err := os.Create(*cpuprofile)
		if err != nil {
			log.Fatal(err)
		}
		pprof.StartCPUProfile(f)
		defer pprof.StopCPUProfile()
	}

	if *version {
		fmt.Println(Version)
		os.Exit(0)
	}

	if *indexName == "" {
		log.Fatal("index name required")
	}

	if len(serverFlags) == 0 {
		serverFlags = append(serverFlags, "http://localhost:9200")
	}

	if *verbose {
		log.Printf("using %d servers", len(serverFlags))
	}

	var file io.Reader = os.Stdin

	if flag.NArg() > 0 {
		f, err := os.Open(flag.Arg(0))
		if err != nil {
			log.Fatalln(err)
		}
		defer f.Close()
		file = f
	}

	runtime.GOMAXPROCS(*maxProcs)

	var username, password string
	if len(*user) > 0 {
		parts := strings.Split(*user, ":")
		if len(parts) != 2 {
			log.Fatal("http basic auth syntax is: username:password")
		}
		username = parts[0]
		password = parts[1]
	}

	options := esbulk.Options{
		Servers:   serverFlags,
		Index:     *indexName,
		DocType:   *docType,
		BatchSize: *batchSize,
		Verbose:   *verbose,
		Scheme:    "http",
		IDField:   *idfield,
		Username:  username,
		Password:  password,
	}

	if *verbose {
		log.Println(options)
	}

	if *purge {
		if err := esbulk.DeleteIndex(options); err != nil {
			log.Fatal(err)
		}
		time.Sleep(5 * time.Second)
	}

	// Create index if not exists.
	if err := esbulk.CreateIndex(options); err != nil {
		log.Fatal(err)
	}

	if *mapping != "" {
		var reader io.Reader
		if _, err := os.Stat(*mapping); os.IsNotExist(err) {
			reader = strings.NewReader(*mapping)
		} else {
			file, err := os.Open(*mapping)
			if err != nil {
				log.Fatal(err)
			}
			reader = bufio.NewReader(file)
		}
		err := esbulk.PutMapping(options, reader)
		if err != nil {
			log.Fatal(err)
		}
	}

	ips := ipAddresses()
	sis := esbulk.ShardInfo(*indexName)
	for _, si := range sis {
		for _, ip := range ips {
			if ip == si.IP {
				log.Printf("Found IP match %s; setting shard to %s", ip, si.Shard)
				options.Routing = si.Shard
			}
		}
	}

	queue := make(chan string)
	var wg sync.WaitGroup

	for i := 0; i < *numWorkers; i++ {
		wg.Add(1)
		go esbulk.Worker(fmt.Sprintf("worker-%d", i), options, queue, &wg)
	}

	reader := bufio.NewReader(file)

	counter := 0
	start := time.Now()

	for {
		line, err := reader.ReadString('\n')
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatal(err)
		}
		line = strings.TrimSpace(line)
		if len(line) == 0 {
			continue
		}
		queue <- line
		counter++
	}

	close(queue)
	wg.Wait()
	elapsed := time.Since(start)

	if *memprofile != "" {
		f, err := os.Create(*memprofile)
		if err != nil {
			log.Fatal(err)
		}
		pprof.WriteHeapProfile(f)
		f.Close()
	}

	rate := float64(counter) / elapsed.Seconds()
	log.Printf("%d docs in %s at %0.3f docs/s with %d workers\n", counter, elapsed, rate, *numWorkers)
}

func ipAddresses() []string {
	ifaces, err := net.Interfaces()
	if err != nil {
		panic(err)
	}
	ips := make([]string, 0, len(ifaces))
	for _, i := range ifaces {
		addrs, err := i.Addrs()
		if err != nil {
			panic(err)
		}
		for _, addr := range addrs {
			switch v := addr.(type) {
			case *net.IPNet:
				ips = append(ips, v.IP.String())
			case *net.IPAddr:
				ips = append(ips, v.IP.String())
			}
			// process IP address
		}
	}
	return ips
}
